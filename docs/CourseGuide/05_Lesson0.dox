\addtogroup CG_Lesson0

Lesson 0 introduces students to the **C++ Course Template**, a professional-grade repository used throughout the course.
Before writing any code, students must understand:

- how the project is organized  
- where their work belongs  
- how instructor code interacts with student code  
- how examples, tests, documentation, and build tools fit together  

This environment models a real-world software engineering workflow.

---

## 1.0 Purpose of the Template

The repository provides:

1. **A clean separation** between *instructor reference code* and *student implementation code*.  
2. **Automatic discovery** of examples and tests using CMake naming conventions.  
3. **Documentation generation** through Doxygen.  
4. **Continuous integration** via CTest + GitHub Actions.  
5. **Scaffolding for modular design**, showing industry-standard practices.

The goal is for students to learn C++ within a reproducible, professional framework.

---

## 2.0 Why the Repository Is Organized This Way

A typical C++ project contains:

- **Headers** (`*.hpp`, `*.h`)  
- **Source files** (`*.cpp`)  
- **Tests**  
- **Examples / drivers**  
- **Documentation**  
- **Build scripts**  

The template organizes these into **strictly separated trees**:

```
course/    ← instructor-only
student/   ← student-only
docs/      ← documentation
cmake/     ← helper modules
.github/   ← CI pipelines
```

This separation ensures:

- students cannot accidentally modify instructor code  
- instructors can safely update course materials throughout the semester  
- tests can link against *both* student and instructor libraries  
- build rules remain consistent and reproducible  

This mirrors how large-scale engineering teams structure multi-module C++ systems.

---

## 3.0 Why File Extensions Are Chosen This Way

### 3.1 `.hpp` (Header Files)
Used for:

- public API declarations  
- class definitions  
- documentation blocks  

`hpp` is preferred over `.h` because it explicitly indicates C++ content.

### 3.2 `.cpp` (Implementation Files)
Used for:

- private/internal implementations  
- logic not exposed publicly  
- example drivers  
- unit test sources  

### 3.3 `.cc` (Unit Test Files)
Chosen to **distinguish tests** from regular `.cpp` sources.

This allows CMake to automatically discover tests:

```
*_unitTests.cc
```

### 3.4 `.dox` (Documentation Pages)
These are Markdown-style documentation pages consumed by Doxygen.
Using `.dox` avoids confusion with regular `*.md` files and supports:

- `@page`  
- `@ingroup`  
- `\addtogroup`  

---

## 4.0 Public vs Private APIs

Both instructor and student code follow the same pattern:

### Public API
Located in:

```
include/<Module>_publicAPI.hpp
```

This file:

- defines what the module exposes  
- is visible to *other* modules  
- contains documentation blocks  
- contains declarations, not implementations  

### Private Implementation
Located in:

```
src/<Module>_privateAPI.cpp
```

This file:

- contains the actual logic  
- is not publicly visible  
- can include private helper functions/classes  

This separation teaches students how real-world C++ libraries are architected.

---

## 5.0 Example Targets vs. Unit Tests

### 5.1 Example Executables (`*_target.cpp`)

Purpose:

- allow students to manually run simple programs  
- demonstrate usage of APIs  
- serve as debug entry points  

CMake finds them via:

```
*_target.cpp
```

### 5.2 Unit Tests (`*_unitTests.cc`)

Purpose:

- validate correctness  
- enforce requirements  
- run automatically through CTest  
- support auto-grading (CI)  

Instructor tests often include student public headers:

```cpp
#include <StudentExample_publicAPI.hpp>
```

And link against:

```
StudentLib  →  CourseLib
```

This ensures instructor evaluation is performed on student code.

---

## 6.0 How CMake Builds Everything

CMake creates:

### 6.1 `CourseLib`
Built from:

```
course/src/
course/include/
```

This is **read-only** for students.

### 6.2 `StudentLib`
Built from:

```
student/src/
student/include/
```

And links against `CourseLib`.

### 6.3 Automatic discovery
CMake automatically creates executables for:

```
course/examples/*_target.cpp
student/examples/*_target.cpp
course/tests/*_unitTests.cc
student/tests/*_unitTests.cc
```

No manual changes required.
Students simply add files in the correct locations.

---

## 7.0 Documentation Philosophy

The structure encourages students to document their code professionally.

### In `include/…_publicAPI.hpp` you document:

- high-level purpose  
- function/class interfaces  
- expected behavior  
- input constraints / output guarantees  

### In `.dox` pages you document:

- lessons  
- workflows  
- architecture  
- conceptual explanations  

This mirrors real-deployment systems (e.g., Google Style Guides + internal wikis).

---

## 8.0 Why We Use This Template

Students learn:

- real CMake workflows  
- modular architecture  
- test-driven development  
- documentation best practices  
- CI pipelines  
- library-versus-application separation  

This prepares them for:

- internships  
- professional engineering work  
- open-source collaboration  

---

## 9.0 Boilerplate Code Walkthrough

### 9.1 Instructor Boilerplate Code (`CourseLib`)

#### Public header — `course/include/LectureExample_publicAPI.hpp`

```cpp
#ifndef LECTURE_EXAMPLE_PUBLIC_API_HPP
#define LECTURE_EXAMPLE_PUBLIC_API_HPP

namespace LectureLib {

void MyPublicAPI();

} // namespace LectureLib

#endif
```

#### Implementation — `course/src/LectureExample_privateAPI.cpp`

```cpp
#include "LectureExample_publicAPI.hpp"
#include <iostream>

namespace LectureLib {

void MyPublicAPI() {
    std::cout << "[Lecture] Public API called\n";
}

void MyPrivateAPI() {
    std::cout << "[Lecture] Private API called\n";
}

} // namespace LectureLib
```

#### Example — `course/examples/LectureExample_target.cpp`

```cpp
#include <LectureExample_publicAPI.hpp>
#include <iostream>

int main() {
    std::cout << "[Example] Calling instructor public API...\n";
    LectureLib::MyPublicAPI();
    return 0;
}
```

**Running the example produces:**

```
[Example] Calling instructor public API...
[Lecture] Public API called
```

Because:

1. The example prints a header message  
2. It calls `LectureLib::MyPublicAPI()`  
3. That function prints its own message  
4. This validates correct linking between example → library → implementation  


---

### 9.2 Student Boilerplate Code (`StudentLib`)

#### Public header — `student/include/StudentExample_publicAPI.hpp`

```cpp
#ifndef STUDENT_EXAMPLE_PUBLIC_API_HPP
#define STUDENT_EXAMPLE_PUBLIC_API_HPP

namespace StudentLib {

void MyPublicAPI();

} // namespace StudentLib

#endif
```

#### Implementation — `student/src/StudentExample_privateAPI.cpp`

```cpp
#include "StudentExample_publicAPI.hpp"
#include <iostream>

namespace StudentLib {

void MyPublicAPI() {
    std::cout << "[Student] Public API called\n";
}

void MyPrivateAPI() {
    std::cout << "[Student] Private API called\n";
}

} // namespace StudentLib
```

#### Example — `student/examples/StudentExample_target.cpp`

```cpp
#include <StudentExample_publicAPI.hpp>
#include <iostream>

int main() {
    std::cout << "[Example] Calling student public API...\n";
    StudentLib::MyPublicAPI();
    return 0;
}
```

**Output:**

```
[Example] Calling student public API...
[Student] Public API called
```

**This confirms:**

- correct linking  
- correct include paths  
- correct namespace usage  
- the student library is functional  

---

### 9.3 How Instructor Tests Validate Student Code

Example test:

```cpp
#include <StudentExample_publicAPI.hpp>
#include <cassert>

int main() {
    StudentLib::MyPublicAPI();
    assert(1 == 1);
    return 0;
}
```

**Why instructor tests use student headers:**

- tests validate *student* public APIs  
- they must not depend on internal student files  
- linking ensures student implementations exist  

This is identical to how real-world library consumers depend strictly on public headers.

---

## 10.0 Summary — What Lesson 0 Teaches

By the end of Lesson 0, students fully understand:

- repository structure  
- file placement rules  
- naming conventions  
- CMake target architecture  
- public vs private APIs  
- example executables  
- unit test interaction  
- documentation structure  

Students can now safely begin implementation inside:

```
student/src/
student/include/
```